package com.skindow.algorithm;

import lombok.extern.slf4j.Slf4j;

/**
 * Created by Administrator on 2019/8/15.
 * byte： 1个字节；
 char： 2个字节；
 short： 2个字节；
 int： 4个字节；
 long： 8个字节；
 float： 4个字节；（6位小数，指数是：10^-38~10^38; 范围：）
 double： 8个字节；
 在计算机中负数采用二进制的补码表示，10进制转为二进制得到的是源码，将源码按位取反得到的是反码，反码加1得到补码
 */
@Slf4j
public class AnOperationTest {
    public static void main(String[] args)
    {
        byte i_1 = 8; //00001000
        byte i_2 = 31;//00011111
        //=== 1. and运算 & === 相同位只要1个为0就是0
        //00001000 即8
        log.info("i_1 & i_2 {}",(i_2 & i_1));
        //=== 2. or运算 | ===  相同位只要一个为1即为1
        //00011111 31
        log.info("i_1 | i_2 {}",(i_2 | i_1));
        //=== 3. xor异或运算 ^ === 相同位不同则为1，相同则为0。
        //00010111 23
        log.info("i_1 ^ i_2 {}",(i_2 ^ i_1));
        //=== 4. not运算 ~ ===  0和1全部取反 按位取反是对补码进行运算，当运算完后，再将补码变回原码。
        //         00001000
        //按位取反 11110111
        //    减一 11110110
        //  再取反 00001001 -9 符号位取反变为负 ~n = -(n+1)
        log.info("~i_1 {}",(~i_1));
        //=== 5. shl运算 << === a shl b就表示把a转为二进制后左移b位 末尾用0补充 高位遗弃
        //i_1 << 2 00001000 向左移2位  00100000  即32
        log.info("i_1 << 2 {}",(i_1 << 2 ));
        //=== 5. shl运算 >> === a shl b就表示把a转为二进制后右移b位去掉末尾0
        //i_1 >> 2 00001000 向左移2位  00000010  即2 最高位是0，左边补齐0；最高为是1，左边补齐1；
        log.info("i_1 >> 2 {}",(i_1 >> 2 ));
        //=== 6. 无符号位右移 >> === 无符号右移，忽略符号位，空位都以0补齐
        //i_1 >>> 2
    }
}
